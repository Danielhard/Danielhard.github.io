<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 执行的AO/VO | Danielhard的前端笔记</title>
    <meta name="description" content="step by step for a Full stack">
    
    
    <link rel="preload" href="/assets/css/0.styles.a02f6941.css" as="style"><link rel="preload" href="/assets/js/app.5c6037cb.js" as="script"><link rel="preload" href="/assets/js/2.082e12d9.js" as="script"><link rel="preload" href="/assets/js/13.f678d7f6.js" as="script"><link rel="prefetch" href="/assets/js/10.9deb2a08.js"><link rel="prefetch" href="/assets/js/11.842648f5.js"><link rel="prefetch" href="/assets/js/12.d3d6d6a2.js"><link rel="prefetch" href="/assets/js/14.fcbf7455.js"><link rel="prefetch" href="/assets/js/15.7cf0b9e8.js"><link rel="prefetch" href="/assets/js/16.d23d7877.js"><link rel="prefetch" href="/assets/js/17.71f474e7.js"><link rel="prefetch" href="/assets/js/18.b524aa71.js"><link rel="prefetch" href="/assets/js/19.448a8713.js"><link rel="prefetch" href="/assets/js/20.9d3518c1.js"><link rel="prefetch" href="/assets/js/21.1c2d03ec.js"><link rel="prefetch" href="/assets/js/22.5c5233a2.js"><link rel="prefetch" href="/assets/js/23.80f19ee8.js"><link rel="prefetch" href="/assets/js/24.b87cd00f.js"><link rel="prefetch" href="/assets/js/25.fbb4af51.js"><link rel="prefetch" href="/assets/js/26.7781b184.js"><link rel="prefetch" href="/assets/js/27.4065852b.js"><link rel="prefetch" href="/assets/js/28.2c772aeb.js"><link rel="prefetch" href="/assets/js/29.aeb8adbd.js"><link rel="prefetch" href="/assets/js/3.4f8d9a06.js"><link rel="prefetch" href="/assets/js/30.f4a63fbc.js"><link rel="prefetch" href="/assets/js/31.7401067b.js"><link rel="prefetch" href="/assets/js/32.dacd01a8.js"><link rel="prefetch" href="/assets/js/33.b4caf845.js"><link rel="prefetch" href="/assets/js/34.1fecdd8f.js"><link rel="prefetch" href="/assets/js/35.3256e4f8.js"><link rel="prefetch" href="/assets/js/36.b6a81b1a.js"><link rel="prefetch" href="/assets/js/37.e8212bcc.js"><link rel="prefetch" href="/assets/js/38.13adce45.js"><link rel="prefetch" href="/assets/js/39.090a1cfa.js"><link rel="prefetch" href="/assets/js/4.167f4d3b.js"><link rel="prefetch" href="/assets/js/40.13501eeb.js"><link rel="prefetch" href="/assets/js/41.c66148b8.js"><link rel="prefetch" href="/assets/js/42.45d8454b.js"><link rel="prefetch" href="/assets/js/43.f4ce8f7e.js"><link rel="prefetch" href="/assets/js/44.c14e2024.js"><link rel="prefetch" href="/assets/js/45.bc1af6e4.js"><link rel="prefetch" href="/assets/js/46.e605b212.js"><link rel="prefetch" href="/assets/js/47.3d074211.js"><link rel="prefetch" href="/assets/js/48.08e28418.js"><link rel="prefetch" href="/assets/js/49.4b565f02.js"><link rel="prefetch" href="/assets/js/5.db9199f1.js"><link rel="prefetch" href="/assets/js/50.255f038b.js"><link rel="prefetch" href="/assets/js/51.3edef65b.js"><link rel="prefetch" href="/assets/js/52.476f761c.js"><link rel="prefetch" href="/assets/js/53.8b55355b.js"><link rel="prefetch" href="/assets/js/54.8411ba2f.js"><link rel="prefetch" href="/assets/js/55.7764be3c.js"><link rel="prefetch" href="/assets/js/56.36aa97c2.js"><link rel="prefetch" href="/assets/js/57.6d39658a.js"><link rel="prefetch" href="/assets/js/6.768f9de4.js"><link rel="prefetch" href="/assets/js/7.20a18e96.js"><link rel="prefetch" href="/assets/js/8.f9f6b6a6.js"><link rel="prefetch" href="/assets/js/9.44d7f83b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a02f6941.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Danielhard的前端笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/FE/introduction.html" class="nav-link">FE</a></div><div class="nav-item"><a href="https://github.com/Danielhard" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/FE/introduction.html" class="nav-link">FE</a></div><div class="nav-item"><a href="https://github.com/Danielhard" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE/base/js_scope.html" class="active sidebar-link">JS 执行的AO/VO</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE/base/js_scope.html#js-执行的ao-vo" class="sidebar-link">JS 执行的AO/VO</a></li><li class="sidebar-sub-header"><a href="/FE/base/js_scope.html#具名函数表达式-nfe-named-function-expression" class="sidebar-link">具名函数表达式--NFE(Named Function Expression)</a></li></ul></li><li><a href="/FE/base/OOP.html" class="sidebar-link">ECMAScript6</a></li><li><a href="/FE/base/隐式转换.html" class="sidebar-link">js中的隐式转换</a></li><li><a href="/FE/base/es6.html" class="sidebar-link">esModule 和 COMMONJS</a></li><li><a href="/FE/base/数据类型.html" class="sidebar-link">js数据类型</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>QA</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MVVM相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>源码解析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>php</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Nginx</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="js-执行的ao-vo"><a href="#js-执行的ao-vo" aria-hidden="true" class="header-anchor">#</a> JS 执行的AO/VO</h2> <ul><li>AO：Activive Object，即函数的活动对象。</li> <li>VO：Variable Object，即变量对象。</li></ul> <p><strong>它们的作用是帮助js引擎在引用变量的时候能够顺利找到变量。并且它们之间的联系可以实现作用域链</strong></p> <p>javascript 作用域链及闭包,AO,VO,执行环境</p> <p>js变量作用域：</p> <p>定义：变量在它申明的函数体以及函数体内嵌套的任意函数体内有定义。</p> <div class="language- extra-class"><pre class="language-text"><code>
function AA(){

  var bb='我是AA内部变量';
  
   function TT(){
        alert(bb);
     }
   alert(bb);
    TT();
}
AA();
</code></pre></div><p>如上图，两次弹出的都是“我是AA内部变量”。</p> <p>JS的变量作用域是函数级的，也就是在AA内部申明的变量，在AA内部任意位置，包括它嵌套的函数内也是有定义的。</p> <p>在函数AA外面，bb就是没有定义的。当然如果去掉bb前面var，bb变量就会自动变成全局变量，此时bb在函数AA外也会有效。</p> <p>JS变量提升：</p> <pre><code>定义：函数体内申明的变量，会被自动提前到最前面申明。
</code></pre> <div class="language- extra-class"><pre class="language-text"><code>function AA(){
  alert(bb);//undefined
  alert(cc);//报错，变量未定义
  var bb='我是AA内部变量';
  alert(bb);//我是AA内部变量
}
</code></pre></div><p>如上，会依次 返回 undefined，报错，我是AA内部变量</p> <p>第一次alert为什么没有报错呢？这就是变量提升的原因，js执行时会自动将变量申明提升到最前面，但是赋值并不会因此提升。</p> <p>提升之后就等价于下面这样。</p> <div class="language- extra-class"><pre class="language-text"><code>function AA(){
  var bb;  //定义自动提前，不赋值，
  alert(bb);
  bb='我是AA内部变量';
}
 
</code></pre></div><p>JS执行环境</p> <p>执行环境或者叫执行上下文，我理解为代码执行时所处的环境，这个环境决定了它有权访问哪些变量或者函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var bb='全局变量'
function AA(){
  var bb='局部变量';
  var s=function(){
    alert(bb);
  }
  s();
  return s;
}
var cc=AA();//局部变量
cc();       //局部变量
</code></pre></div><p>如上，依次进入的执行环境是window，AA，s</p> <p>window---全局执行环境</p> <p>AA，s ---函数执行环境</p> <p>变量对象VO[variable object]  活动对象AO[activation object]</p> <p>每个执行环境都有一个变量对象，这个变量对象的属性绑定了在这个环境里定义的所有变量和函数，形参。VO理解为代码编译时产生。</p> <p>VO绑定以下属性：</p> <p>1.函数形参</p> <p>2.函数申明</p> <p>3.变量申明</p> <p>函数被调用后，执行环境就切换成了对应的函数，此时活动对象就会产生。也就是说AO可以理解为函数执行时产生的。</p> <p>进入函数执行环境后，实际上AO就相当于函数的VO，只是说在函数执行环境里 VO属性不能被直接访问，所以生成AO来替代访问。</p> <div class="language- extra-class"><pre class="language-text"><code>var bb='全局变量'
function AA(y){
  var bb='局部变量';
  function s(){
    alert(bb);
  }
}
</code></pre></div><p>AA(5);</p> <p>上面代码依次进入的执行环境有两个，首先window，然后是函数AA</p> <p>全局执行环境window：VO绑定的属性依次，函数AA，变量bb</p> <p>函数AA执行环境：VO绑定的属性依次是，形参y=5，函数s，变量bb</p> <p>在全局执行环境中，VO属性是可以被访问的，而进入函数执行环境后VO属性不能被直接访问，此时会生成活动对象AO替代VO，可以访问AO属性。</p> <p>VO/AO产生的过程也是变量提升的过程，优先提升函数，然后是变量。</p> <p>此时VO[function]===AO</p> <p>注：在函数执行环境中，用表达式的方式申明的函数,对应的函数表达式不会加入VO</p> <div class="language- extra-class"><pre class="language-text"><code>function AA(){
var sub = function _sub(a, b){
    alert(typeof _sub);
    return a - b;
}

}
</code></pre></div><p>sub作为变量会加入VO，_sub作为函数表达式则不会加入。</p> <p>JS作用域链</p> <pre><code>作用域链包含了执行环境有权访问的变量、函数的有序访问。它是一个由变量对象(VO/AO)组成的单向链表，主要用来进行变量查找。
</code></pre> <p>JS内部有一个[[scope]]属性，这个属性就是指向作用域链的顶端。</p> <div class="language- extra-class"><pre class="language-text"><code>var bb='全局变量'
function AA(y){
  var bb='局部变量';
  function s(){
    var z=0;
    alert(bb);
  }
  s();
}
AA(5);
</code></pre></div><p>暂且理解JS在代码编译时创建作用域链，分析上面的代码的 作用域链：</p> <p>全局执行环境：[[scope]]-----&gt;VO[AA,bb]  只有全局VO，[[scope]]直接指向VO。</p> <p>函数AA执行环境：[[scope]]----&gt;VO[[y,s,bb]VO[[AA,bb]]，首先全局VO压入栈，然后函数AA VO压入栈顶，[[scope]]属性指向栈顶，变量、函数搜索就从栈顶开始。</p> <p>函数s执行环境:[[scope]]---&gt;VO[[z]]VO[[y,s,bb]VO[[AA,bb]]，首先全局VO压入栈，然后依次AA，s压入栈，s处于栈顶，[[scope]]属性直接指向s的VO。</p> <p>应用：比如调用s，进入s执行环境，在执行alert时，首先会去查找bb的申明，会先在作用域链的顶端查找，没查到就会沿着链继续往下查找，直到查到就停止。</p> <p>总结：</p> <p>函数执行时，将当前的函数的VO放在链表开头，后面依次是上层函数，最后是全局对象。变量查找则依次从链表的顶端开始。JS有个内部属性[[scope]]，这个属性包含了</p> <p>函数的作用域对象的集合，这个集合就称为函数的作用域链。它决定了，哪些变量或者函数能在当前函数中被访问，以及它的访问顺序。</p> <p>闭包</p> <p>我理解为，函数能够访问另一个函数中的变量，这样就构成了一个闭包。只要某个变量在另外一个函数中还存在引用，那么这个变量的值在内存中就不会被释放，除非这个函数不会再执行。</p> <div class="language- extra-class"><pre class="language-text"><code>function getvalue(){
 for(var i=0;i&lt;10;i++){
     var yy=i;
      setTimeout(
      function(){
      var zz=document.getElementById('tt').innerText;
      zz+=',';
      zz+=yy;
      document.getElementById('tt').innerText=zz;
      }
      ,
      100)
    }
}
</code></pre></div><p>定时器中的匿名函数会在for结束之后依次执行，匿名函数中引用了变量yy，根据作用域链规则查找，首先在匿名函数中寻找yy的定义，没有找到，然后去它的上层查找。</p> <p>yy定义在getvalue中，又yy被其他函数引用着，所以它的结果不会被释放。</p> <p>而for循环执行结束之后yy的结果是9，所以最后的输出会是：,9,9,9,9,9,9,9,9,9,9</p> <p>那如果我们想要输出0123456789怎么办呢？看下面的代码</p> <div class="language- extra-class"><pre class="language-text"><code>function getvalue(){
for(var i=0;i&lt;10;i++){
 var yy=i;
(
 function(yy)
 {
 setTimeout(
  function(){
  var zz=document.getElementById('tt').innerText;
  zz+=',';
  zz+=yy;
  document.getElementById('tt').innerText=zz;
  }
  ,
  100)
  }
  )(yy)
}
}
</code></pre></div><p>上面在定时器外面套了一个立即执行函数</p> <p>(function(yy){</p> <p>....</p> <p>})(yy)</p> <p>代码执行到这个匿名函数时，这个匿名函数会自动执行，也就是for循环，每次循环到这里这个函数就会立即执行掉，并把参数yy传入匿名函数中。</p> <p>现在来看定时器中的匿名函数的作用域链。</p> <p>[[scope]]---&gt;VO[[变量z]] VO[[形参yy,匿名function]] VO[[匿名function,变量yy]] VO[[函数getvalue]]</p> <p>此时，定时中的匿名函数引用的变量yy，从作用域链中查找可以发现，它来自于上层立即执行函数的形参，而立即执行函数是每次</p> <p>for循环都会立即执行并把参数传入。我们知道，只要某个变量在另外一个函数中还存在引用，那么这个变量的值在内存中就不会被释放，</p> <p>系统会每次把立即函数执行的形参传入值保存起来，所以定时器的中的匿名函数在执行结果就会是下面这样。</p> <p>,0,1,2,3,4,5,6,7,8,9
每个函数都是一个执行环境，每个执行环境的[[scope]]都会指向一条作用域链。
可以认为，定时器外的函数会执行10次，函数每次执行，系统都会给他分配一个空间，这个空间保存了它的作用域链[[scope]]，变量对象VO/AO[形参，函数申明，变量申明]等信息，
如果它的变量还会被其他函数继续引用，比如定时器中的匿名函数，那么它就不会销毁,等待被使用，反之执行完就会销毁。
既然没有销毁，那么定时器中的匿名函数在执行时，就能获取到想要的值。
这个例子中，定时器中的匿名函数与定时器外的立即执行函数构成闭包。</p> <p>浅谈this</p> <p>一般而言，this指向执行环境所处的环境，也就是函数被调用时所处的环境。看到资料说：函数调用f(x,y)其实内部是f.call(this, x, y)这样执行的，所以this是在调用的时候传入的。</p> <p>如果函数是直接执行的那么this指向window，如果有调用者，那么this指向调用者。</p> <div class="language- extra-class"><pre class="language-text"><code>var a=1;
var BB=function(){
  alert(this.a);
}

var DD={
   a:4,
   f:BB
}
BB();//1 this 指向window
var zz=DD.f;
zz(); //1 this指向window
DD.f(); //4 this指向f的调用者DD
</code></pre></div><p>上面的例子说明，作为对象方法时，this指向的是函数的调用者，直接调用或者在一般函数中调用时，this指向的就是全局对象</p> <div class="language- extra-class"><pre class="language-text"><code>var a=1;
var BB=function(){
this.a=2;
}
var zz=new BB();//this 指向new出来的对象
alert(a); //1 所以this.a赋值不会影响全局变量中的a，此时的this指向的不是全局对象
alert(zz.a);//2 
BB();//直接执行，this指向window，执行之后，全局变量a的值被改变
alert(a); //2 
</code></pre></div><p>上面说明，作为构造函数时，函数里的this指向的是new出来的对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var a=1;
function BB(){
 alert(this.a);
}
function CC(){
this.a=3;
}
BB();  //1
var dd=new CC();
BB.apply(dd); //3 实际上this指向dd
BB.call(dd);//3   实际上this指向dd
</code></pre></div><p>上面说明，call和apply可以改变this的指向，使用call、apply时，传入的第一个参数就会成为this的指向对象。</p> <h2 id="具名函数表达式-nfe-named-function-expression"><a href="#具名函数表达式-nfe-named-function-expression" aria-hidden="true" class="header-anchor">#</a> 具名函数表达式--NFE(Named Function Expression)</h2> <div class="language- extra-class"><pre class="language-text"><code>    var b = 10;
    (function b(){
    	b = 20;
    	console.log(b); // 输出位置1
    })();
    console.log(b); // 输出位置2
</code></pre></div><p>结果:
位置1:</p> <div class="language- extra-class"><pre class="language-text"><code>  ƒ b(){
    b = 20;
    console.log(b); // 输出位置1
  }
</code></pre></div><pre><code>位置2: 10
</code></pre> <p>NFE特性1，函数名（b）不能再绑定其它值（不可更改），b=20无效，下面的代码使用严格模式，则会报错：Uncaught TypeError: Assignment to constant
NFE特性2，函数名（b）只能在函数内部访问，位置2访问到的是var b=10处定义的b
个人认为：在自执行的NFE中，修改函数名称引用变量无效</p> <div class="language- extra-class"><pre class="language-text"><code>    var b = function a() {
  		console.log(a)  //[Function A]
  		a = 1
	  	console.log(a)  //[Function A]
	  }
  	console.log(a) //Uncaught ReferenceError: a is not defined
</code></pre></div><p>注意事项：</p> <p>1.在IIFE中如果有具名函数定义为A，那么对A进行修改是无效的，而对其他的变量进行定义会生效（如果函数内不存在，则会被定义成全局变量）</p> <div class="language- extra-class"><pre class="language-text"><code>  	(function A () {
	  	console.log(A) //[Function A]
	  	A = 1
	  	B = 1 //没有用var，会被定义成全局变量
	  	console.log(window.A) //undefined 
	  	console.log(B) //1 
	  	console.log(A) //[Function A]
  	})()
</code></pre></div><p>2.如果不是IIFE，直接声明具名函数A(不是赋值给变量)，在A内定义A或者修改A，前者会定义一个函数作用域的变量，后者会定义一个全局作用域的变量</p> <div class="language- extra-class"><pre class="language-text"><code>  	function A() {
	    console.log(A); // [Function A]
	    A = 1;
	    console.log(window.A); // 1
	    console.log(A); // 1
  	}
  	A();
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/FE/base/OOP.html">ECMAScript6</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5c6037cb.js" defer></script><script src="/assets/js/2.082e12d9.js" defer></script><script src="/assets/js/13.f678d7f6.js" defer></script>
  </body>
</html>
