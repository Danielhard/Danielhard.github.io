(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{209:function(n,r,a){"use strict";a.r(r);var t=a(0),e=Object(t.a)({},(function(){var n=this,r=n.$createElement,a=n._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"高级算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级算法","aria-hidden":"true"}},[n._v("#")]),n._v(" 高级算法")]),n._v(" "),a("p",[a("strong",[n._v("介绍三种高级算法")])]),n._v(" "),a("ul",[a("li",[n._v("分治法")]),n._v(" "),a("li",[n._v("动态规划")]),n._v(" "),a("li",[n._v("贪心算法")])]),n._v(" "),a("h2",{attrs:{id:"分治法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分治法","aria-hidden":"true"}},[n._v("#")]),n._v(" 分治法")]),n._v(" "),a("p",[n._v("分治法(Divide-and-Conquer):将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后\n再合并结果。就得到原问题的解。\n分治模式在每一层递归上都有三个步骤:")]),n._v(" "),a("ul",[a("li",[n._v("分解(Divide):将原问题分解成一系列的子问题")]),n._v(" "),a("li",[n._v("解决(Conquer):递归的解决各个子问题，若子问题足够小，则直接求解。")]),n._v(" "),a("li",[n._v("合并(Combine):将子问题的结果合并成原问题的解。")])]),n._v(" "),a("p",[n._v("案例：最大子数组问题。在一个数列当中寻找一个子数列，使得这个子数列的元素之和最大。")]),n._v(" "),a("ul",[a("li",[n._v("分解： 将原数组重中间拆分为2个小数组。最大子数组，要么在左边小数组。要么在右边小数组。要么在左右小数组之间")]),n._v(" "),a("li",[n._v("解决： 如果小数组元素很多，继续拆分，当拆到1个元素的数组时，直接求值。")]),n._v(" "),a("li",[n._v("合并：分别将最大左小数组，最大右小数组，中间数组的最大子数组进行合并。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("   // 分治法\n    function findMaxSubArray(array, start, end) {\n      if (start == end) {\n        return [start, end, array[start]];\n      }\n      const mid = Math.floor((start + end) / 2);\n      const leftMaxSum = findMaxSubArray(array, start, mid);\n      const rightMaxSum = findMaxSubArray(array, mid + 1, end);\n      const acrossMaxSum = findAcrossMidSubArray(array, start, end);\n    \n      if (leftMaxSum[2] > rightMaxSum[2] && leftMaxSum[2] > acrossMaxSum[2]) {\n        return leftMaxSum;\n      }\n    \n      if (rightMaxSum[2] > leftMaxSum[2] && rightMaxSum[2] > acrossMaxSum[2]) {\n        return rightMaxSum;\n      }\n      return acrossMaxSum;\n    }\n    \n    // 在左右数组之间\n    function findAcrossMidSubArray(array, start, end) {\n      if (start == end) {\n        return [start, end, array[start]];\n      }\n    \n      const mid = Math.floor((start + end) / 2);\n      //求左侧最大数组值及下标\n      var leftMaxSum = Number.NEGATIVE_INFINITY;\n      var leftSum = 0;\n      var maxArrLeftIdx = mid;\n      for (var i = mid; i >= start; i--) {\n        leftSum += array[i];\n        if (leftSum > leftMaxSum) {\n          leftMaxSum = leftSum;\n          maxArrLeftIdx = i;\n        }\n      }\n    \n      //求右侧最大数组值\n      var rightMaxSum = Number.NEGATIVE_INFINITY;\n      var rightSum = 0;\n      var maxArrRightIdx = mid;\n      for (var j = mid + 1; j <= end; j++) {\n        rightSum += array[j];\n        if (rightSum > rightMaxSum) {\n          rightMaxSum = rightSum;\n          maxArrRightIdx = j;\n        }\n      }\n      return [maxArrLeftIdx, maxArrRightIdx, leftMaxSum + rightMaxSum];\n    }\n    \n    console.warn(\n      '分治法：',\n      findMaxSubArray([-11, 34, 37, 30, -42, 4, 16, 47, 36, 19], 0, 9)\n    );   \n")])])]),a("h2",{attrs:{id:"动态规划"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态规划","aria-hidden":"true"}},[n._v("#")]),n._v(" 动态规划")]),n._v(" "),a("p",[a("strong",[n._v("动态规划算法的设计可以分为如下4个步骤")])]),n._v(" "),a("ul",[a("li",[n._v("描述最优解的结构。")]),n._v(" "),a("li",[n._v("递归定义最优解的值。")]),n._v(" "),a("li",[n._v("按自底向上的方式计算最优解的值。")]),n._v(" "),a("li",[n._v("由计算出的结果构造一个最优解。\n动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题，在这种情况下。若用分治法则会做许多不\n必要的工作，即重复地求解公共的子问题。动态规划算法对每个子子问题只求解一次,将其结果保存在一张表中，从而避免每次遇到各个子问题时重新\n计算答案。")])]),n._v(" "),a("p",[n._v("案例：计算斐波那契数列，数列中第n项的值 = 第n-1项的值 + 第n - 2 项的值。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  // 斐波那契数列\n    function recurFib(n){\n        if(n<2){\n            return n ;\n\n        }else{\n            return recurFib(n-1) + recurFib(n-2);\n        }\n    }\n    console.log('斐波那契数列',recurFib(100));\n\n    // 动态规划\n    function dynFib(n){\n        var val = [];\n        for(var i =0;i<=n; i++){\n            var[i] = 0;\n        }\n        if(n == 0){\n            return 0;\n        }else if(n==1 || n==2){\n            return 1;\n        }else{\n            val[0] = 0;\n            val[1] = 1;\n            val[2] = 1;\n            for(var i = 3;i<=n;i++){\n                val[i] = val[i-1]  + val[i-2];\n            }\n            return val[n];\n        }\n    }\n    console.log('动态规划',dynFib(10))\n  \n    //动态规划，不用数组\n    function iterFib(n){\n        if(n>0){\n            var last = 1;\n            var nestLast = 1;\n            var result = 1;\n            for(var i = 2; i< n ; i++ ){\n                result = last  + nestLast ;\n                nestLast = last;\n                last = result;\n            }\n            return result;\n        }else{\n            return 0;\n        }\n    }\n    console.log('动态规划不用数组',iterFib(10));\n")])])]),a("h2",{attrs:{id:"贪心算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法","aria-hidden":"true"}},[n._v("#")]),n._v(" 贪心算法")]),n._v(" "),a("pre",[a("code",[n._v("贪心算法(greedy algorithm),又称贪心算法，是一种在每一步选择中都采取在当前状态下最好或者最优(即最有利)的选择，\n从而希望导致结果是最好或最优的算法。例如在找零钱时，默认先找最大的金额，然后依次减小，那这就是一种贪心算法。\n\n贪心算法在对问题求解时，总是做出在当前看来是最好的选择。也就是说。不从整体最优上加以考虑，他所做出的仅是在某种意义\n上的局部最优解。\n\n案例：老师分饼干。每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。目标是尽量让更多的孩子满意。 \n如孩子的要求是[1,3,5,4,2],饼干大小是[1,1],最多能让1个孩子满足。如孩子的要求是[10,9,8,7,6],饼干大小是\n[7,6,5] 。最多能让2个孩子满足。\n\nvar findContentChildren = function(children,cake){\n    let sortChildren = children.sort((a,b)=>a-b);\n    let sortCake = cake.sort((a,b)=> a-b);\n    var i  = 0 , j = 0;\n    var result = 0;\n\n    while(sortChildren[i]&&sortCake[j]){\n        if(sortChildren[i] <= sortCake[j]){\n            result++;\n            i++;\n        }\n        j++;\n    }\n    return result;\n};   ")])])])}),[],!1,null,null,null);r.default=e.exports}}]);