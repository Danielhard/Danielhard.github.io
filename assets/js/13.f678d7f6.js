(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{213:function(n,t,a){"use strict";a.r(t);var e=a(0),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"js-执行的ao-vo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-执行的ao-vo","aria-hidden":"true"}},[n._v("#")]),n._v(" JS 执行的AO/VO")]),n._v(" "),a("ul",[a("li",[n._v("AO：Activive Object，即函数的活动对象。")]),n._v(" "),a("li",[n._v("VO：Variable Object，即变量对象。")])]),n._v(" "),a("p",[a("strong",[n._v("它们的作用是帮助js引擎在引用变量的时候能够顺利找到变量。并且它们之间的联系可以实现作用域链")])]),n._v(" "),a("p",[n._v("javascript 作用域链及闭包,AO,VO,执行环境")]),n._v(" "),a("p",[n._v("js变量作用域：")]),n._v(" "),a("p",[n._v("定义：变量在它申明的函数体以及函数体内嵌套的任意函数体内有定义。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\nfunction AA(){\n\n  var bb='我是AA内部变量';\n  \n   function TT(){\n        alert(bb);\n     }\n   alert(bb);\n    TT();\n}\nAA();\n")])])]),a("p",[n._v("如上图，两次弹出的都是“我是AA内部变量”。")]),n._v(" "),a("p",[n._v("JS的变量作用域是函数级的，也就是在AA内部申明的变量，在AA内部任意位置，包括它嵌套的函数内也是有定义的。")]),n._v(" "),a("p",[n._v("在函数AA外面，bb就是没有定义的。当然如果去掉bb前面var，bb变量就会自动变成全局变量，此时bb在函数AA外也会有效。")]),n._v(" "),a("p",[n._v("JS变量提升：")]),n._v(" "),a("pre",[a("code",[n._v("定义：函数体内申明的变量，会被自动提前到最前面申明。\n")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function AA(){\n  alert(bb);//undefined\n  alert(cc);//报错，变量未定义\n  var bb='我是AA内部变量';\n  alert(bb);//我是AA内部变量\n}\n")])])]),a("p",[n._v("如上，会依次 返回 undefined，报错，我是AA内部变量")]),n._v(" "),a("p",[n._v("第一次alert为什么没有报错呢？这就是变量提升的原因，js执行时会自动将变量申明提升到最前面，但是赋值并不会因此提升。")]),n._v(" "),a("p",[n._v("提升之后就等价于下面这样。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function AA(){\n  var bb;  //定义自动提前，不赋值，\n  alert(bb);\n  bb='我是AA内部变量';\n}\n \n")])])]),a("p",[n._v("JS执行环境")]),n._v(" "),a("p",[n._v("执行环境或者叫执行上下文，我理解为代码执行时所处的环境，这个环境决定了它有权访问哪些变量或者函数。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var bb='全局变量'\nfunction AA(){\n  var bb='局部变量';\n  var s=function(){\n    alert(bb);\n  }\n  s();\n  return s;\n}\nvar cc=AA();//局部变量\ncc();       //局部变量\n")])])]),a("p",[n._v("如上，依次进入的执行环境是window，AA，s")]),n._v(" "),a("p",[n._v("window---全局执行环境")]),n._v(" "),a("p",[n._v("AA，s ---函数执行环境")]),n._v(" "),a("p",[n._v("变量对象VO[variable object]  活动对象AO[activation object]")]),n._v(" "),a("p",[n._v("每个执行环境都有一个变量对象，这个变量对象的属性绑定了在这个环境里定义的所有变量和函数，形参。VO理解为代码编译时产生。")]),n._v(" "),a("p",[n._v("VO绑定以下属性：")]),n._v(" "),a("p",[n._v("1.函数形参")]),n._v(" "),a("p",[n._v("2.函数申明")]),n._v(" "),a("p",[n._v("3.变量申明")]),n._v(" "),a("p",[n._v("函数被调用后，执行环境就切换成了对应的函数，此时活动对象就会产生。也就是说AO可以理解为函数执行时产生的。")]),n._v(" "),a("p",[n._v("进入函数执行环境后，实际上AO就相当于函数的VO，只是说在函数执行环境里 VO属性不能被直接访问，所以生成AO来替代访问。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var bb='全局变量'\nfunction AA(y){\n  var bb='局部变量';\n  function s(){\n    alert(bb);\n  }\n}\n")])])]),a("p",[n._v("AA(5);")]),n._v(" "),a("p",[n._v("上面代码依次进入的执行环境有两个，首先window，然后是函数AA")]),n._v(" "),a("p",[n._v("全局执行环境window：VO绑定的属性依次，函数AA，变量bb")]),n._v(" "),a("p",[n._v("函数AA执行环境：VO绑定的属性依次是，形参y=5，函数s，变量bb")]),n._v(" "),a("p",[n._v("在全局执行环境中，VO属性是可以被访问的，而进入函数执行环境后VO属性不能被直接访问，此时会生成活动对象AO替代VO，可以访问AO属性。")]),n._v(" "),a("p",[n._v("VO/AO产生的过程也是变量提升的过程，优先提升函数，然后是变量。")]),n._v(" "),a("p",[n._v("此时VO[function]===AO")]),n._v(" "),a("p",[n._v("注：在函数执行环境中，用表达式的方式申明的函数,对应的函数表达式不会加入VO")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function AA(){\nvar sub = function _sub(a, b){\n    alert(typeof _sub);\n    return a - b;\n}\n\n}\n")])])]),a("p",[n._v("sub作为变量会加入VO，_sub作为函数表达式则不会加入。")]),n._v(" "),a("p",[n._v("JS作用域链")]),n._v(" "),a("pre",[a("code",[n._v("作用域链包含了执行环境有权访问的变量、函数的有序访问。它是一个由变量对象(VO/AO)组成的单向链表，主要用来进行变量查找。\n")])]),n._v(" "),a("p",[n._v("JS内部有一个[[scope]]属性，这个属性就是指向作用域链的顶端。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var bb='全局变量'\nfunction AA(y){\n  var bb='局部变量';\n  function s(){\n    var z=0;\n    alert(bb);\n  }\n  s();\n}\nAA(5);\n")])])]),a("p",[n._v("暂且理解JS在代码编译时创建作用域链，分析上面的代码的 作用域链：")]),n._v(" "),a("p",[n._v("全局执行环境：[[scope]]-----\x3eVO[AA,bb]  只有全局VO，[[scope]]直接指向VO。")]),n._v(" "),a("p",[n._v("函数AA执行环境：[[scope]]----\x3eVO[[y,s,bb]VO[[AA,bb]]，首先全局VO压入栈，然后函数AA VO压入栈顶，[[scope]]属性指向栈顶，变量、函数搜索就从栈顶开始。")]),n._v(" "),a("p",[n._v("函数s执行环境:[[scope]]---\x3eVO[[z]]VO[[y,s,bb]VO[[AA,bb]]，首先全局VO压入栈，然后依次AA，s压入栈，s处于栈顶，[[scope]]属性直接指向s的VO。")]),n._v(" "),a("p",[n._v("应用：比如调用s，进入s执行环境，在执行alert时，首先会去查找bb的申明，会先在作用域链的顶端查找，没查到就会沿着链继续往下查找，直到查到就停止。")]),n._v(" "),a("p",[n._v("总结：")]),n._v(" "),a("p",[n._v("函数执行时，将当前的函数的VO放在链表开头，后面依次是上层函数，最后是全局对象。变量查找则依次从链表的顶端开始。JS有个内部属性[[scope]]，这个属性包含了")]),n._v(" "),a("p",[n._v("函数的作用域对象的集合，这个集合就称为函数的作用域链。它决定了，哪些变量或者函数能在当前函数中被访问，以及它的访问顺序。")]),n._v(" "),a("p",[n._v("闭包")]),n._v(" "),a("p",[n._v("我理解为，函数能够访问另一个函数中的变量，这样就构成了一个闭包。只要某个变量在另外一个函数中还存在引用，那么这个变量的值在内存中就不会被释放，除非这个函数不会再执行。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function getvalue(){\n for(var i=0;i<10;i++){\n     var yy=i;\n      setTimeout(\n      function(){\n      var zz=document.getElementById('tt').innerText;\n      zz+=',';\n      zz+=yy;\n      document.getElementById('tt').innerText=zz;\n      }\n      ,\n      100)\n    }\n}\n")])])]),a("p",[n._v("定时器中的匿名函数会在for结束之后依次执行，匿名函数中引用了变量yy，根据作用域链规则查找，首先在匿名函数中寻找yy的定义，没有找到，然后去它的上层查找。")]),n._v(" "),a("p",[n._v("yy定义在getvalue中，又yy被其他函数引用着，所以它的结果不会被释放。")]),n._v(" "),a("p",[n._v("而for循环执行结束之后yy的结果是9，所以最后的输出会是：,9,9,9,9,9,9,9,9,9,9")]),n._v(" "),a("p",[n._v("那如果我们想要输出0123456789怎么办呢？看下面的代码")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function getvalue(){\nfor(var i=0;i<10;i++){\n var yy=i;\n(\n function(yy)\n {\n setTimeout(\n  function(){\n  var zz=document.getElementById('tt').innerText;\n  zz+=',';\n  zz+=yy;\n  document.getElementById('tt').innerText=zz;\n  }\n  ,\n  100)\n  }\n  )(yy)\n}\n}\n")])])]),a("p",[n._v("上面在定时器外面套了一个立即执行函数")]),n._v(" "),a("p",[n._v("(function(yy){")]),n._v(" "),a("p",[n._v("....")]),n._v(" "),a("p",[n._v("})(yy)")]),n._v(" "),a("p",[n._v("代码执行到这个匿名函数时，这个匿名函数会自动执行，也就是for循环，每次循环到这里这个函数就会立即执行掉，并把参数yy传入匿名函数中。")]),n._v(" "),a("p",[n._v("现在来看定时器中的匿名函数的作用域链。")]),n._v(" "),a("p",[n._v("[[scope]]---\x3eVO[[变量z]] VO[[形参yy,匿名function]] VO[[匿名function,变量yy]] VO[[函数getvalue]]")]),n._v(" "),a("p",[n._v("此时，定时中的匿名函数引用的变量yy，从作用域链中查找可以发现，它来自于上层立即执行函数的形参，而立即执行函数是每次")]),n._v(" "),a("p",[n._v("for循环都会立即执行并把参数传入。我们知道，只要某个变量在另外一个函数中还存在引用，那么这个变量的值在内存中就不会被释放，")]),n._v(" "),a("p",[n._v("系统会每次把立即函数执行的形参传入值保存起来，所以定时器的中的匿名函数在执行结果就会是下面这样。")]),n._v(" "),a("p",[n._v(",0,1,2,3,4,5,6,7,8,9\n每个函数都是一个执行环境，每个执行环境的[[scope]]都会指向一条作用域链。\n可以认为，定时器外的函数会执行10次，函数每次执行，系统都会给他分配一个空间，这个空间保存了它的作用域链[[scope]]，变量对象VO/AO[形参，函数申明，变量申明]等信息，\n如果它的变量还会被其他函数继续引用，比如定时器中的匿名函数，那么它就不会销毁,等待被使用，反之执行完就会销毁。\n既然没有销毁，那么定时器中的匿名函数在执行时，就能获取到想要的值。\n这个例子中，定时器中的匿名函数与定时器外的立即执行函数构成闭包。")]),n._v(" "),a("p",[n._v("浅谈this")]),n._v(" "),a("p",[n._v("一般而言，this指向执行环境所处的环境，也就是函数被调用时所处的环境。看到资料说：函数调用f(x,y)其实内部是f.call(this, x, y)这样执行的，所以this是在调用的时候传入的。")]),n._v(" "),a("p",[n._v("如果函数是直接执行的那么this指向window，如果有调用者，那么this指向调用者。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var a=1;\nvar BB=function(){\n  alert(this.a);\n}\n\nvar DD={\n   a:4,\n   f:BB\n}\nBB();//1 this 指向window\nvar zz=DD.f;\nzz(); //1 this指向window\nDD.f(); //4 this指向f的调用者DD\n")])])]),a("p",[n._v("上面的例子说明，作为对象方法时，this指向的是函数的调用者，直接调用或者在一般函数中调用时，this指向的就是全局对象")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var a=1;\nvar BB=function(){\nthis.a=2;\n}\nvar zz=new BB();//this 指向new出来的对象\nalert(a); //1 所以this.a赋值不会影响全局变量中的a，此时的this指向的不是全局对象\nalert(zz.a);//2 \nBB();//直接执行，this指向window，执行之后，全局变量a的值被改变\nalert(a); //2 \n")])])]),a("p",[n._v("上面说明，作为构造函数时，函数里的this指向的是new出来的对象。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var a=1;\nfunction BB(){\n alert(this.a);\n}\nfunction CC(){\nthis.a=3;\n}\nBB();  //1\nvar dd=new CC();\nBB.apply(dd); //3 实际上this指向dd\nBB.call(dd);//3   实际上this指向dd\n")])])]),a("p",[n._v("上面说明，call和apply可以改变this的指向，使用call、apply时，传入的第一个参数就会成为this的指向对象。")]),n._v(" "),a("h2",{attrs:{id:"具名函数表达式-nfe-named-function-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具名函数表达式-nfe-named-function-expression","aria-hidden":"true"}},[n._v("#")]),n._v(" 具名函数表达式--NFE(Named Function Expression)")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    var b = 10;\n    (function b(){\n    \tb = 20;\n    \tconsole.log(b); // 输出位置1\n    })();\n    console.log(b); // 输出位置2\n")])])]),a("p",[n._v("结果:\n位置1:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  ƒ b(){\n    b = 20;\n    console.log(b); // 输出位置1\n  }\n")])])]),a("pre",[a("code",[n._v("位置2: 10\n")])]),n._v(" "),a("p",[n._v("NFE特性1，函数名（b）不能再绑定其它值（不可更改），b=20无效，下面的代码使用严格模式，则会报错：Uncaught TypeError: Assignment to constant\nNFE特性2，函数名（b）只能在函数内部访问，位置2访问到的是var b=10处定义的b\n个人认为：在自执行的NFE中，修改函数名称引用变量无效")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    var b = function a() {\n  \t\tconsole.log(a)  //[Function A]\n  \t\ta = 1\n\t  \tconsole.log(a)  //[Function A]\n\t  }\n  \tconsole.log(a) //Uncaught ReferenceError: a is not defined\n")])])]),a("p",[n._v("注意事项：")]),n._v(" "),a("p",[n._v("1.在IIFE中如果有具名函数定义为A，那么对A进行修改是无效的，而对其他的变量进行定义会生效（如果函数内不存在，则会被定义成全局变量）")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  \t(function A () {\n\t  \tconsole.log(A) //[Function A]\n\t  \tA = 1\n\t  \tB = 1 //没有用var，会被定义成全局变量\n\t  \tconsole.log(window.A) //undefined \n\t  \tconsole.log(B) //1 \n\t  \tconsole.log(A) //[Function A]\n  \t})()\n")])])]),a("p",[n._v("2.如果不是IIFE，直接声明具名函数A(不是赋值给变量)，在A内定义A或者修改A，前者会定义一个函数作用域的变量，后者会定义一个全局作用域的变量")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  \tfunction A() {\n\t    console.log(A); // [Function A]\n\t    A = 1;\n\t    console.log(window.A); // 1\n\t    console.log(A); // 1\n  \t}\n  \tA();\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);