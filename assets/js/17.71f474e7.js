(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{219:function(e,t,o){"use strict";o.r(t);var i=o(0),r=Object(i.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"csrf-跨站请求伪造"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#csrf-跨站请求伪造","aria-hidden":"true"}},[e._v("#")]),e._v(" CSRF 跨站请求伪造")]),e._v(" "),o("p",[e._v("预防:")]),e._v(" "),o("p",[e._v("1.Cookie 的 samesite属性")]),e._v(" "),o("p",[e._v("原理：从第三方站点发起请求禁止cookie发送。\n在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项")]),e._v(" "),o("p",[e._v("SameSite 选项通常有 Strict、Lax 和 None 三个值。")]),e._v(" "),o("ul",[o("li",[e._v("Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。")]),e._v(" "),o("li",[e._v("Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。")]),e._v(" "),o("li",[e._v("而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。")])]),e._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[e._v("验证请求的来源站点（Referer和origin属性）")])]),e._v(" "),o("pre",[o("code",[e._v("Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的\n\n但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性。Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。\n因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。\n")])]),e._v(" "),o("ol",{attrs:{start:"3"}},[o("li",[e._v("CSRF Token")])]),e._v(" "),o("p",[e._v("在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中\n第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。")])])}),[],!1,null,null,null);t.default=r.exports}}]);