(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{224:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"vue-源码分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-源码分析","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue 源码分析")]),e._v(" "),n("h3",{attrs:{id:"目录结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#目录结构","aria-hidden":"true"}},[e._v("#")]),e._v(" 目录结构")]),e._v(" "),n("pre",[n("code",[e._v("```\n  --src \n    -- compiler\n    -- core \n    -- entries\n    -- platforms\n    -- server\n    -- sfc \n    -- shared\n\n```\n")])]),e._v(" "),n("ol",[n("li",[e._v("/copmplier 目录是编译模板")]),e._v(" "),n("li",[e._v("/core目录是vue.js 的核心")]),e._v(" "),n("li",[e._v("/entries目录是生产打包的入口")]),e._v(" "),n("li",[e._v("/platforms目录是针对核心模块的'平台'模块")]),e._v(" "),n("li",[e._v("platforms 目录下暂时只有web目录 （在最新的开发目录下边已经有weex 目录）。web目录下有对应的\n/compiler 、 /runtime 、/server 、 /util目录")]),e._v(" "),n("li",[e._v("/server 目录是处理服务端渲染")]),e._v(" "),n("li",[e._v("/sfc目录处理但文件 .vue")]),e._v(" "),n("li",[e._v("/shared 目录提供全局用到的工具函数。")])]),e._v(" "),n("ul",[n("li",[e._v("结论： Vue整体组成由core(核心)+对应的'平台'补充代码构成(独立构建和运行时构建只是platforms下web平台的两种选择),")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  Vue  -- core \n          -- components\n          -- global-api\n          -- instance\n          -- observer\n          -- util\n          -- vdom\n       -- platforms\n\n")])])]),n("ul",[n("li",[n("p",[e._v("Vue.js的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件\n1.components 模板编译的代码\n2.global-api 最上层的文件接口\n3.instance生命周期-> init.js\n4.observer 数据收集与订阅\n5.util常用工具方法类\n6.vdom虚拟dom")])]),e._v(" "),n("li",[n("p",[e._v("双向绑定原理\n模板渲染解析时watcher会对应绑定指令(一对一).此时会通过调用订阅者watcher初始化(watcher中get()方法)去触发对应属性在发布者observer里(object.defineProperty)的getter,observer会判断是不是通过watcher初始化调用的（Dep.target,实例化之后会清空），只有是才会通过dep类依赖收集，observer通过depend通知Dep类收集(addDep方法，在watcher类中，会传入当前Dep实例调用自身)当前该订阅者(watcher)中的触发更新的方法，同时第一次初始化watcher.update()初始化视图。此后每次的数据更新都会通过observer中的setter去触发dep类中的回调update执行收集依赖的所有方法更新订阅者中的状态同时更新视图。observer在处理对象和数组的时候，如果是数组，并且调用的方法会改变数组长度，则会利用重写原型链方法,执行原始方式，拦截新增，遍历递归代理新增数据，然后手动触发一次setter做的事情(因为调用数组原生APi可能多次触发getter setter 且索引不会变)，如果是对象则\n通过对象的getter获取值和setter更新值.")])]),e._v(" "),n("li",[n("p",[e._v("observer观察者")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("   function Dep(){ // 主题对象\n      this.subs = []; //订阅者列表\n   }\n   // 主体对象通知订阅者\n   Dep.prototype.notify = function(){\n     // 遍历所有的订阅者，执行订阅者提供的更新方法\n     this.subs.forEach(function(sub){\n       sub.update();\n     })\n   }\n\n   function Sub(x){ // 订阅者\n     this.x = x \n   }\n   //订阅者更新 \n   Sub.prototype.update = function(){\n     this.x = this.x + 1\n   }\n   \n\n   var pub ={\n     publish:function(){\n       dep.notify();\n     }\n   };\n   var dep = new Dep(); //主题对象实例\n   dep.subs.push(new Sub(1),new Sub(2));\n   // 新增2个订阅者\n   pub.publish();//发布者发布更新\n")])])])]),e._v(" "),n("li",[n("p",[e._v("Dep")])]),e._v(" "),n("li",[n("p",[e._v("watcher\nwatcher中的get回调会将当前实例vm对应key的值赋值给当前watcher类的value ，然后在update中赋值给当前节点(node)对应的(type)属性")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    [\n      watcher1,// {{text}}   (if setter)=>(else init)update->get->getter\n      watcher2 // {{v-model}}   update\n    ]\n")])])])])]),e._v(" "),n("p",[e._v("##从挂载到渲染")]),e._v(" "),n("p",[e._v("1.实例化\nnew Vue({"),n("br"),e._v("\nel:'app',\ndata:{}\n})")]),e._v(" "),n("p",[e._v("2.传入的data挂载到vue实例身上\n3.observe  -- definedProperty 数据的响应式")]),e._v(" "),n("ol",[n("li",[e._v("创建一个dep ,收集对应的watcher")]),e._v(" "),n("li",[e._v("对于数据构建响应 同时做了get 和 set处理")]),e._v(" "),n("li",[e._v("defineProperty的get，Dep.target => Dep.addSub =>收集依赖")]),e._v(" "),n("li",[e._v("定义set  => dep.notify"),n("br"),e._v("\n4.渲染 Complie (返回dom节点插到页面上)")]),e._v(" "),n("li",[e._v("传入node节点 vm")]),e._v(" "),n("li",[e._v("nodeToFragment => document.createDocumentFragment 创建文档片段\n它在内存中，所以不会造成太大的性能问题")]),e._v(" "),n("li",[e._v("while(child = node.firstChild) => complieElement => 添加到文档片段里面")]),e._v(" "),n("li",[e._v("compileElement => 判断节点类型,修正模板  (new Watcher()); 分不同场景获取的值。文本节点的nodevalue 还有指令获取\n1 . "+e._s(e.text)+"文本=> name(test) -> 获取到我们在模板里面使用的data里面的key\n2 . 一个指令对应声明一个watcher")]),e._v(" "),n("li",[e._v("watcher实例化 , Dep.target = this => update ->(observer) get ->dep.addSub()")]),e._v(" "),n("li",[e._v("get到值之后，nodeValue = value  同时进行dom-diff get阶段就是打patch的时候。")]),e._v(" "),n("li",[e._v("batcher (vue的调度 eventLoop)")])]),e._v(" "),n("p",[e._v("##API")]),e._v(" "),n("ul",[n("li",[e._v("keep-alive\nlru缓存算法，保存vdom 使用后来的，清空先来的")]),e._v(" "),n("li",[e._v("use\nVue.use() 传入function 或者对象，判断是否存在 有直接返回。没有判断类型执行")])]),e._v(" "),n("h2",{attrs:{id:"_3-0"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-0","aria-hidden":"true"}},[e._v("#")]),e._v(" 3.0")]),e._v(" "),n("ul",[n("li",[e._v("Proxy(一层)")]),e._v(" "),n("li",[e._v("compiler-core与平台无关的编辑器（AST）")]),e._v(" "),n("li",[e._v("compiler-dom专门针对浏览器写的编辑器")]),e._v(" "),n("li",[e._v("reactivity 数据相应系统，单独的系统，可以配合任何使用")]),e._v(" "),n("li",[e._v("runtime-core 与平台无关的运行时，实现虚拟dom渲染器（虚拟 dom与此层分离 ）、vue组件，vue Api 、可以利用这一层\n具体实现某个平台的runtime，自定义渲染器")]),e._v(" "),n("li",[e._v("runtime-dom: 专门针对浏览器的运行时，dom api,dom 事件，dom 属性")]),e._v(" "),n("li",[e._v("runtime-test:辅助dom渲染测试工具")]),e._v(" "),n("li",[e._v("server-renderer : ssr")])]),e._v(" "),n("blockquote",[n("p",[e._v("3.0性能提升")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  /**\n  *  不需要深层遍历，proxy直接调用取值\n  *  与2.0不同，不需要深层递归遍历一级一级获取值\n  *\n  *\n  **/\n\n   function isObject(res){\n      ?isReadOnly\n      ?lazy\n      readOnly(res)?\n      reactivity(res)\n      :res\n\n   }\n  \n")])])]),n("p",[e._v("reactive?\n//依赖收集  取到effectStack[lastIndex] 放进targetMap完成依赖的收集\ntargetMap{\n{a:1} // 原始数据，作为键值的key\n:\n{\na:{\nreactiveEffect(()=>{\nrun(effect,fn,args)\n})\n}\n}\n}")]),e._v(" "),n("p",[e._v("effect 传入的函数，默认执行一次，函数里面发生修改的时候，再次执行对应的effect 这一层做的是数据变更之后的渲染->接入渲染操作")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  effect(fn)->createReactiveEffect(fn)=>返回一个函数 =>1effect()// 执行 ,\n  // 收集依赖第一次执行 \n  1effect = createReactiveEffect??  里面返回 ⬇️ //reactiveEffect里面返回一个run的闭包，执行effect里的fn顺便添加依赖。这里的effect都是每个函数体内自己定义的，createReactiveEffect 执行和reactiveEffect函数 都被声明effect代替\n  // 依赖 \n  effect = reactiveEffect(()=>{\n    return run(effect,fn,args)\n  })\n // ---\n  run === effectStack.includes(effect)?  effectStack.push(effect)  // 收集依赖推进栈\n  => fn(...args) ->触发 get() ->track ->effectStack[lastIndex]  // 执行了fn之后，先推入依赖再触发get，所以effectStack最后一个就是当前入栈的依赖\n  ->track啥呢  拿依赖 ：  effect=reactiveEffect(()=>{\n    return run(effect,fn,args)\n  })\n\n\n setter triger   targetMap->target->deps -> 遍历（effect）  =  new Set()=> computedRunners.add(effect)  effect.add(effect)\n 添加完成之后遍历执行里边的run(effect)\n   effect = reactiveEffect(()=>{\n    return run(effect,fn,args)\n  })\n    run === effectStack.includes(effect)? \n  => fn(...args)  //更新视图，依赖已经收集不会重新收集\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);