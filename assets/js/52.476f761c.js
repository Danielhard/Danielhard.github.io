(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{249:function(e,t,a){"use strict";a.r(t);var r=a(0),i=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"常见的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 常见的问题")]),e._v(" "),a("blockquote",[a("p",[e._v("tree-shaking 不能完全生效")])]),e._v(" "),a("h3",{attrs:{id:"tree-shaking-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-原理","aria-hidden":"true"}},[e._v("#")]),e._v(" tree-shaking 原理")]),e._v(" "),a("ol",[a("li",[e._v("ES6 的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。")])]),e._v(" "),a("p",[e._v("ES6 module 特点：")]),e._v(" "),a("ul",[a("li",[e._v("只能作为模块顶层的语句出现")]),e._v(" "),a("li",[e._v("import 的模块名只能是字符串常量")]),e._v(" "),a("li",[e._v("import binding 是 immutable (不可变) 的")])]),e._v(" "),a("p",[e._v("ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础。所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("分析程序流，判断哪些变量未被使用、引用，进而删除此代码")])]),e._v(" "),a("p",[e._v("Tree-shaking 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）。")]),e._v(" "),a("p",[e._v("Dead Code 一般具有以下几个特征")]),e._v(" "),a("p",[e._v("•代码不会被执行，不可到达")]),e._v(" "),a("p",[e._v("•代码执行的结果不会被用到")]),e._v(" "),a("p",[e._v("•代码只会影响死变量（只写不读）")]),e._v(" "),a("h3",{attrs:{id:"在-tree-shaking-上能够尽力的事。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在-tree-shaking-上能够尽力的事。","aria-hidden":"true"}},[e._v("#")]),e._v(" 在 tree-shaking 上能够尽力的事。")]),e._v(" "),a("ol",[a("li",[e._v("尽量不写带有副作用的代码。诸如编写了立即执行函数，在函数里又使用了外部变量等。")]),e._v(" "),a("li",[e._v("如果对 ES6 语义特性要求不是特别严格，可以开启 babel 的 loose 模式，这个要根据自身项目判断，如：是否真的要不可枚举 class 的属性。")]),e._v(" "),a("li",[e._v("如果是开发 JavaScript 库，请使用 rollup。并且提供 ES6 module 的版本，入口文件地址设置到 package.json 的 module 字段。")]),e._v(" "),a("li",[e._v("如果 JavaScript 库开发中，难以避免的产生各种副作用代码，可以将功能函数或者组件，打包成单独的文件或目录，以便于用户可以通过目录去加载。如有条件，也可为自己的库开发单独的 webpack-loader，便于用户按需加载。")]),e._v(" "),a("li",[e._v("如果是工程项目开发，对于依赖的组件，只能看组件提供者是否有对应上述 3、4 点的优化。对于自身的代码，除 1、2 两点外，对于项目有极致要求的话，可以先进行打包，最终再进行编译。")]),e._v(" "),a("li",[e._v("如果对项目非常有把握，可以通过 uglify 的一些编译配置，如：pure_getters: true，删除一些强制认为不会产生副作用的代码。")])])])}),[],!1,null,null,null);t.default=i.exports}}]);