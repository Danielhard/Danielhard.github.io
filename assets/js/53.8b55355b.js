(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{250:function(e,r,t){"use strict";t.r(r);var i=t(0),o=Object(i.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack")]),e._v(" "),t("blockquote",[t("p",[e._v("webpack是一个打包模块化javascript的工具。将一切视为模块，通过loader(编译器)转换对应文件,plugin注入钩子，最后输出资源模块组合成文件")])]),e._v(" "),t("blockquote",[t("p",[e._v("主要由entry,output,modules,plugins")])]),e._v(" "),t("blockquote",[t("p",[e._v("构建流程")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("基础概念")]),e._v(" "),t("ol",[t("li",[e._v("compiler:Webpack的运行入口，实例化时定义webpack构建主要流程，同时创建构建时的核心对象compilation")]),e._v(" "),t("li",[e._v("compilation:由compiler实例化，存储构建过程中流程使用的数据，用于控制这些数据的变化，每一次构建创建一个compilation实例")]),e._v(" "),t("li",[e._v("Chunk:一般一个入口对应一个Chunk")]),e._v(" "),t("li",[e._v("Module:用于表示代码模块的类型。有很多子类用于处理不同情况的模块，模块相关信息都可以从Module实例中获取，例如dependiencies记录模块的信息")]),e._v(" "),t("li",[e._v("Parser:基于acorn来分析AST语法树，解析出代码模块的依赖")]),e._v(" "),t("li",[e._v("Dependency:解析时用于保存代码模块对应的依赖使用的对象")]),e._v(" "),t("li",[e._v("Template:生成最终代码要使用到的代码模块")])])]),e._v(" "),t("li",[t("p",[e._v("基本流程")]),e._v(" "),t("ol",[t("li",[e._v("创建compiler实例，用于控制构建流程，compiler实例包含webpack基本环境信息")]),e._v(" "),t("li",[e._v("根据配置项转换成对应内部插件，并初始化options选项")]),e._v(" "),t("li",[e._v("执行compiler.run")]),e._v(" "),t("li",[e._v("创建compilation实例，每次构建都会新创建一个compilation实例，包含了这次构建的基本信息")]),e._v(" "),t("li",[e._v("从entry开始递归分析依赖，对每个依赖模块进行buildModule，通过Loader将不同类型的模块转换成webpack模块")]),e._v(" "),t("li",[e._v("调用Parser.parse将上面的结果转换成AST树")]),e._v(" "),t("li",[e._v("遍历AST树，收集依赖Dependency，并保存在compilation实例的dependiencies属性中")]),e._v(" "),t("li",[e._v("生成chunks，不同entry生成不同chunk,动态导入也会生成自己的chunk，生成chunk之后还会进行优化")]),e._v(" "),t("li",[e._v("使用Template基于compilation的数据生成代码")])])]),e._v(" "),t("li",[t("p",[e._v("编译过程\n第一步先初始化参数，通过yargs将webpack.config.js和shell脚本的配置信息合并。进行参数的初始化，第二步利用初始化的参数创建compiler对\n象,compiler可以视为一个webpack实例，存在于webpack从启动到结束的整个过程，它包含了webpack的module、plugin等参数信息，然后调用\ncompiler.run进行编译，第三步根据entry配置信息找到入口文件，创建compliaion对象，可以理解为webpack一次编译的过程，包含了当前编译环境\n的所有资源，包括编译后的文件。第四步通过配置信息，调用loader进行模块翻译，使用acorn将模块转换为AST，当遇到require依赖时，创建依赖并加入依赖\n数组，再找出依赖的依赖，递归异步的处理所有依赖。第五步完成第四步后将得到所有模块的依赖关系和模块翻译后的文件，然后调用compilation.seal方法，\n对这些模块和根据模块依赖关系创建的chunk进行整理。将所有资源进行合并拆分等操作，这是最后一次能修改输出内容的地方。第六步根据配置信息中的output配置\n，进行最后的模块文件输出，制定输出文件名和文件路径。")])]),e._v(" "),t("li",[t("p",[e._v("原理\nwebpack打包输出后的文件其实是一个闭包，传入的参数是一个对象。键值为所有输出文件的路径，内容为eval包裹的文件内容；闭包内重写了模块的加载方式。\n自己定义了"),t("code",[e._v("_webpack_require")]),e._v("方法，来实现模拟的commonjs规范模块加载机制。\nwebpack实际上是基于事件流的，通过一系列的插件来运行。webpack利用tapable库提供各种钩子来实现对于整个构建流程各个步骤的控制")])])]),e._v(" "),t("h2",{attrs:{id:"常见api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见api","aria-hidden":"true"}},[e._v("#")]),e._v(" 常见Api")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("require.context\n通过执行require.context函数获取一个特定的上下文,主要用来实现自动化导入模块,在前端工程中,如果遇到从一个文件夹引入很多模块的情况,可以使用这个api,它会遍历文件夹中的指定文件,然后自动导入,使得不需要每次显式的调用import导入模块\n（可以考虑路由替换）")]),e._v(" "),t("p",[e._v("require.context函数接受三个参数")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n> directory {String} -读取文件的路径\n\n> useSubdirectories {Boolean} -是否遍历文件的子目录\n\n> regExp {RegExp} -匹配文件的正则\n\n语法: require.context(directory, useSubdirectories = false, regExp = /^.//);\n")])])]),t("p",[e._v("借用webpack官网的例子")]),e._v(" "),t("blockquote",[t("p",[e._v("require.context('./test', false, /.test.js$/);\n"),t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/24/167de378702c5a09?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})])]),e._v(" "),t("pre",[t("code",[e._v("在index.js中调用require.context('./test',false,/.test.js)会得到test文件下3个文件的执行环境\n值得注意的是require.context函数执行后返回的是一个函数,并且这个函数有3个属性\n")])]),e._v(" "),t("p",[e._v("· resolve {Function} -接受一个参数request,request为test文件夹下面匹配文件的相对路径,返回这个匹配文件相对于整个工程的相对路径")]),e._v(" "),t("p",[e._v("· keys {Function} -返回匹配成功模块的名字组成的数组")]),e._v(" "),t("p",[e._v("· id {String} -执行环境的id,返回的是一个字符串,主要用在module.hot.accept,应该是热加载?\n这三个都是作为函数的属性(注意是作为函数的属性,函数也是对象,有对应的属性)")]),e._v(" "),t("pre",[t("code",[e._v("三个参数返回\n 代码在里层 index.js\n")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/24/167de37871264735?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),e._v(" "),t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/24/167de3787149e069?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),e._v("\nrequire.context函数执行后的代码赋值给了files变量(函数)")]),e._v(" "),t("pre",[t("code",[e._v("执行了keys方法返回了一个由匹配文件的文件名组成的数组\nid属性返回了匹配的文件夹的相对于工程的相对路径,是否遍历子目录,匹配正则组成的字符串\n对于resolve方法可以看到它是一个函数接受req参数,经过实践我发现这个req参数的值是keys方法返回的数组的元素,接着我们传入其中一个元素执行resolve函数\n")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/24/167de378c6ac2728?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),e._v(" "),t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/24/167de378c88e86ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),e._v(" "),t("pre",[t("code",[e._v("resolve方法返回了一个字符串代表着传入参数的文件相对于整个工程的相对路径\n同时files作为一个函数,也接受一个req参数,这个和resolve方法的req参数是一样的,即匹配的文件名的相对路径,而files函数返回的是一个模块,这个模块才是真正我们需要的\n")])])])}),[],!1,null,null,null);r.default=o.exports}}]);