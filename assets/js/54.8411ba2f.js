(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{255:function(e,n,s){"use strict";s.r(n);var t=s(0),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"细活"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#细活","aria-hidden":"true"}},[e._v("#")]),e._v(" 细活")]),e._v(" "),s("h2",{attrs:{id:"提一嘴node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提一嘴node","aria-hidden":"true"}},[e._v("#")]),e._v(" 提一嘴node")]),e._v(" "),s("ul",[s("li",[e._v("process当前node环境的进程，包括env(返回一个包含用户环境信息的对象)和arg(Node.js 进程被启动时传入的命令行参数)")]),e._v(" "),s("li",[e._v("path是指用于处理文件和目录的路径常用的是resolve和join可以通过解构引入path获得")])]),e._v(" "),s("p",[e._v("1）path.join() 方法会将所有给定的 path 片段连接到一起（使用平台特定的分隔符作为定界符），然后规范化生成的路径。\n"),s("code",[e._v("path.join('/目录1', '目录2', '目录3/目录4', '目录5', '..'); // 返回: '/目录1/目录2/目录3/目录4' path.join(__dirname,'./XXX') 当前目录加相对路径")])]),e._v(" "),s("p",[e._v("2）path.resolve() 方法会将路径或路径片段的序列解析为绝对路径。给定的路径序列会从右到左进行处理，后面的每个 path 会被追加到前面，直到构造出绝对路径。 例如，给定的路径片段序列：/目录1、 /目录2、 目录3，调用 path.resolve('/目录1', '/目录2', '目录3') 会返回 /目录2/目录3，因为 '目录3' 不是绝对路径，但 '/目录2' + '/' + '目录3' 是。\n如果在处理完所有给定的 path 片段之后还未生成绝对路径，则会使用当前工作目录。生成的路径会被规范化，并且尾部的斜杠会被删除（除非路径被解析为根目录）。零长度的 path 片段会被忽略。如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("     path.resolve('/目录1/目录2', './目录3');\n  // 返回: '/目录1/目录2/目录3'\n  \n  path.resolve('/目录1/目录2', '/目录3/目录4/');\n  // 返回: '/目录3/目录4'\n  \n  path.resolve('目录1', '目录2/目录3/', '../目录4/文件.gif');\n  // 如果当前工作目录是 /目录A/目录B，\n  // 则返回 '/目录A/目录B/目录1/目录2/目录4/文件.gif'\n")])])]),s("p",[e._v("相当于一个cd的过程。")]),e._v(" "),s("h2",{attrs:{id:"entry和output"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#entry和output","aria-hidden":"true"}},[e._v("#")]),e._v(" entry和output")]),e._v(" "),s("blockquote",[s("p",[e._v("entry")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   entry: {\n      home: './home.js',\n      about: './about.js',\n      contact: './contact.js'\n      // app: resolve('src/web/index.tsx')  \n   }\n")])])]),s("blockquote",[s("p",[e._v("output")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  output: {\n    filename: '[name].bundle[contenthash:5].js', // 单入口可用静态名称\n    chunkFilename:'', // 非入口(non-entry) chunk 文件的名称\n    path: join(__dirname, '../dist'), // output 目录对应一个绝对路径。\n  }\n   \n")])])]),s("p",[e._v("额外参数:\n1)publicPath:对于按需加载(on-demand-load)或加载外部资源(external resources)（如图片、文件等）来说，output.publicPath 是很重要的选项。如果指定了一个错误的值，则在加载这些资源时会收到 404 错误。此选项指定在浏览器中所引用的「此输出目录对应的公开 URL」。相对 URL(relative URL) 会被相对于 HTML 页面（或 ")]),s("base"),e._v(" 标签）解析。相对于服务的 URL(Server-relative URL)，相对于协议的 URL(protocol-relative URL) 或绝对 URL(absolute URL) 也可是可能用到的，或者有时必须用到，例如：当将资源托管到 CDN 时。该选项的值是以 runtime(运行时) 或 loader(载入时) 所创建的每个 URL 为前缀。因此，在多数情况下，此选项的值都会以 / 结束。"),s("p"),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  const path = require('path');\n  module.exports = {\n    //...\n    output: {\n      path: path.resolve(__dirname, 'public/assets'),\n      publicPath: 'https://cdn.example.com/assets/'\n    }\n  };\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" module.exports = {\n   output: {\n     publicPath: '/assets/',\n     chunkFilename: '[id].chunk.js'\n     // publicPath: 'https://cdn.example.com/assets/', // CDN（总是 HTTPS 协议）\n     // publicPath: '//cdn.example.com/assets/', // CDN（协议相同）\n     // publicPath: '/assets/', // 相对于服务(server-relative)\n     // publicPath: 'assets/', // 相对于 HTML 页面\n     // publicPath: '../assets/', // 相对于 HTML 页面\n     // publicPath: '', // 相对于 HTML 页面（目录相同）\n   }\n };\n   // 对于一个 chunk 请求，看起来像这样 /assets/4.chunk.js\n")])])]),s("p",[e._v("2)chunkFilename需要在运行时根据 chunk 发送的请求去生成。因此，需要在 webpack runtime 输出 bundle 值时，将 chunk id 的值对应映射到占位符(如 [name] 和 [chunkhash])。这会增加文件大小，并且在任何 chunk 的占位符值修改后，都会使 bundle 失效")]),e._v(" "),s("h2",{attrs:{id:"loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loader","aria-hidden":"true"}},[e._v("#")]),e._v(" Loader")]),e._v(" "),s("ul",[s("li",[e._v("MiniCssExtractPlugin.loader 配合mini-css-extract-plugin使用")]),e._v(" "),s("li",[e._v("babel-loader"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  module:{\n      rules:[ \n            {\n              test: /\\.(js|jsx|ts|tsx)(\\?.*)?/,\n              include: [resolve('src')],\n              exclude: /node_modules/,\n              use: [{\n                  loader: 'babel-loader'\n              }]\n          },]\n  }\n")])])])]),e._v(" "),s("li",[e._v("style-loader //JS脚本创建一个style标签 和 css-loader搭配 无法单独用 miniCssExtractLoader将html里的样式，抽取出来放到link标签引入,可在生产使用.开发使用style-loader")]),e._v(" "),s("li",[e._v("css-loader // 识别JS中导入了css 和 style-loader搭配")]),e._v(" "),s("li",[e._v("postcss-loader  // CSS 预处理器加前缀cssnano压缩，csshudini")])]),e._v(" "),s("h2",{attrs:{id:"plugins"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#plugins","aria-hidden":"true"}},[e._v("#")]),e._v(" plugins")]),e._v(" "),s("ul",[s("li",[e._v("当前环境下的webpack打包进度条  webpackSimpleProgressPlugin")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const webpackSimpleProgressPlugin = require('webpack-simple-progress-plugin')\n\n// plugins \n\nplugins:[\n    new webpackSimpleProgressPlugin()\n]\n")])])]),s("ul",[s("li",[e._v("mini-css-extract-plugin  (webpack4.0+)\n将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。 注意webpack 5.0beta dev环境中配置loader修改css会导致derServer挂掉，以后如修改再校正。")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\n// loader \n module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: [\n            {\n               loader: MiniCssExtractPlugin.loader,\n               options: {\n                 // 你可以在这里指定特定的 publicPath\n                 // 默认情况下使用 webpackOptions.output 中的 publicPath\n                 publicPath: '../',\n                 // 仅仅在 development 模式下开启 hmr\n                 hmr: process.env.NODE_ENV === 'development',\n                 // 如果 hmr 不工作, 开启强制选项\n                 reloadAll:true 强制开启\n                },\n            }, 'css-loader'],\n      },\n    ],\n  },\n\n// plugins \n\nplugins:[\n    new MiniCssExtractPlugin()\n]\n")])])]),s("blockquote",[s("p",[e._v("options")])]),e._v(" "),s("ol",[s("li",[e._v("publicPath : output 选项中的 publicPath自定义目标文件的公共路径")]),e._v(" "),s("li",[e._v("esModule : 默认false  默认情况下 mini-css-extract-plugin 将会生成使用 CommonJS 模块语法的 JS 模块。 在某些情况下，使用 ES 模块是有益的，比如： module concatenation 和 tree shaking。")]),e._v(" "),s("li",[e._v("hmr支持在开发中热重载实际的 CSS 文件。  reloadAll:true 强制开启")]),e._v(" "),s("li",[e._v("生产模式压缩,使用类 optimize-css-assets-webpack-plugin 这样的插件。 设置 optimization.minimizer 选项会覆盖 webpack 默认提供的优化器UglyJSplugin，所以还需要提供一个 JS 的优化器：terser-webpack-plugin")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" const TerserJSPlugin = require('terser-webpack-plugin');\n const MiniCssExtractPlugin = require('mini-css-extract-plugin');\n const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');\n \n module.exports = {\n   optimization: {\n     minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({\n         assetNameRegExp: /\\.css$/g,\n         cssProcessor: require('cssnano'),\n         cssProcessorPluginOptions: {\n           preset: [\n             'default',\n             {\n               discardComments: {\n                 removeAll: true,\n               },\n             },\n           ],\n         },\n         canPrint: true,\n     })],\n   },\n   plugins: [\n     new MiniCssExtractPlugin({\n       // 类似于 webpackOptions.output 中的选项\n       // 所有选项都是可选的\n       filename: '[name].css',\n       chunkFilename: '[id].css',\n     }),\n   ],\n   module: {\n     rules: [\n       {\n         test: /\\.css$/,\n         use: [MiniCssExtractPlugin.loader, 'css-loader'],\n       },\n     ],\n   },\n };\n")])])]),s("ol",{attrs:{start:"5"}},[s("li",[e._v('长期缓存\n使用 filename: "[contenthash].css" 启动长期缓存。根据需要添加 [name]。')])]),e._v(" "),s("pre",[s("code",[e._v("```\n   new MiniCssExtractPlugin({\n     filename: '[name].[contenthash].css',\n     chunkFilename: '[id].[contenthash].css',\n   }),\n```\n")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("HtmlWebpackPlugin 生成一个HTML5文件，其中会使用script标签将所有Webpack捆绑包包括在内。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   var HtmlWebpackPlugin = require('html-webpack-plugin');\n   var path = require('path');\n   \n   module.exports = {\n     entry: 'index.js',\n     output: {\n       path: path.resolve(__dirname, './dist'),\n       filename: 'index_bundle.js'\n     },\n     plugins: [new HtmlWebpackPlugin(\n         title: 'yidengdengxuetang',\n         filename: 'index.html',   // 生成的文件名称\n         template: resolve(__dirname, `./src/web/index-${_modeflag?'prod':'dev'}.html`) // 模板绝对路径,此处区分生产开发环境\n         inject: true,\n         minify: {\n           removeComments: true,\n           collapseWhitespace: true,\n           removeAttributeQuotes: true\n           // more options:\n           // https://github.com/kangax/html-minifier#options-quick-reference\n         },\n     )]\n   };\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('\n\x3c!--dist/index.html--\x3e\n  <!DOCTYPE html>\n   <html>\n     <head>\n       <meta charset="UTF-8">\n       <title>webpack App</title>\n     </head>\n     <body>\n       <script src="index_bundle.js"><\/script>\n     </body>\n   </html>\n\n')])])]),s("p",[e._v("有多个webpack入口点，它们将全部包含 < script >在生成的HTML中。用MiniCssExtractPlugin提取的CSS包含< link >在< head >生成的HTML元素中的标记中")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("分析打包体积 webpack-bundle-analyzer")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin  \n    new BundleAnalyzerPlugin({\n       analyzerMode: 'production',\n       analyzerPort: 8888,\n       analyzerHost: '127.0.0.1',\n       openAnalyzer: true\n    })\n")])])])])])]),e._v(" "),s("li",[s("p",[e._v("speed-measure-webpack-plugin 分析打包速度 webpack5暂时不兼容")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  const SpeedNeasurePlugin = require('speed-measure-webpack-plugin')\n  const smp = new SpeedNeasurePlugin()\n  module.exports = smp.wrap(config)\n")])])])]),e._v(" "),s("li",[s("p",[e._v("开启Gzip  compression-webpack-plugin")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  const CompressionWebpackPlugin = require('compression-webpack-plugin')\n  new CompressionWebpackPlugin({\n      asset: '[path].gz[query]',\n      algorithm: 'gzip',\n      test: new RegExp(\n        '\\\\.(' +\n        config.build.productionGzipExtensions.join('|') +\n        ')$'\n      ),\n      threshold: 10240,\n      minRatio: 0.8\n  })\n")])])])])]),e._v(" "),s("h2",{attrs:{id:"other"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#other","aria-hidden":"true"}},[e._v("#")]),e._v(" other")]),e._v(" "),s("ul",[s("li",[e._v("开启缓存\n缓存生成的 webpack 模块和 chunk，来改善构建速度。cache 会在开发 模式被设置成 type: 'memory' 而且在 生产 模式 中被禁用。 cache: true 与 cache: { type: 'memory' } 配置作用一致。 传入 false 会禁用缓存:")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" cache: {\n        type: 'filesystem',\n        // cacheDirectory: path.resolve(__dirname, '.temp_cache')\n    }\n\n")])])]),s("ul",[s("li",[e._v("externals  外部拓展，防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。将资源用CDN或本地引入")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    externals: {\n         react: 'React', //提取react\n        'react-router-dom': 'ReactRouterDOM' // 提取react-route-dom\n    },\n")])])]),s("ul",[s("li",[e._v("sourceMap 定位代码错误，使用后包体积会增大")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" devtool: 'eval-nosources-cheap-module-source-map', // - -本地打包生产环境检查源码错误使用，\n devtool: 'cheap-module-source-map', // 正式生产环境使用\n")])])]),s("ul",[s("li",[s("p",[e._v("合并分环境配置文件")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  const { merge } = require('webpack-merge')\n\n   //  curConfig = {...}  dev prod\n   //  baseConfig = {...}\n   module.export = merge(curConfig,baseConfig)\n")])])])]),e._v(" "),s("li",[s("p",[e._v("devServer"),s("br"),e._v("\n开启webpack-dev-server服务")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   devServer: {\n      // contentBase: join(__dirname, 'dist'), // 告诉服务器内容的来源。仅在需要提供静态文件时才进行配置\n      // publicPath: '/',\n      historyApiFallback: true, // 使用HTML5 history API，你可能需要使用index.html响应404或者问题请求\n      compress: true, //  gzip compression\n      port: 3000\n  },\n")])])])]),e._v(" "),s("li",[s("p",[e._v("Resolve解析模块")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("alias 别名,创建 import 或 require 的别名")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("     alias: {\n       '@assets': resolve('src/web/assets'),\n       '@components': resolve('src/web/components'),\n       '@models': resolve('src/web/models'),\n       '@routes': resolve('src/web/routes'),\n       '@pages': resolve('src/web/pages'),\n       '@utils': resolve('src/web/utils'),\n       '@tools': resolve('src/web/tools'),\n     },\n")])])])]),e._v(" "),s("li",[s("p",[e._v("extensions:尝试按顺序解析这些后缀名。")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   extensions: ['.js', '.ts', '.jsx', '.tsx']\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[e._v("modules: webpack 解析模块时应该搜索的目录")])]),e._v(" "),s("pre",[s("code",[e._v(" 使用绝对路径，将只在给定目录中搜索。\n")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("     modules: ['node_modules', resolve('src')],\n")])])]),s("pre",[s("code",[e._v(" 添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索：\n")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  const path = require('path');\n\n  module.exports = {\n    //...\n    resolve: {\n      modules: [path.resolve(__dirname, 'src'), 'node_modules'],\n    },\n  };\n")])])]),s("ul",[s("li",[e._v("优化(Optimization)")])]),e._v(" "),s("blockquote",[s("p",[e._v("minimizer 提供一个或多个定制过的 TerserPlugin 实例， 覆盖默认压缩工具(minimizer)。")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   const TerserPlugin = require('terser-webpack-plugin');\n   module.exports = {\n     optimization: {\n       minimizer: [\n         new TerserPlugin({\n           cache: true, // 是否缓存\n           parallel: true, // 是否并行打包\n           sourceMap: true, // 如果在生产环境中使用 source-maps，必须设置为 true\n           terserOptions: {\n             // https://github.com/webpack-contrib/terser-webpack-plugin#terseroptions\n           }\n         }),\n       ],\n     }\n   };\n\n")])])]),s("blockquote",[s("p",[e._v("splitChunks  影响按需块，因为更改初始块会影响HTML文件应包含的脚本标签以运行项目,此配置对象表示的默认行为SplitChunksPlugin。\nwebpack将根据以下条件自动拆分块：\n可以共享新块，或者模块来自node_modules文件夹\n新的块将大于20kb（在min + gz之前）\n按需加载块时并行请求的最大数量将小于或等于30\n初始页面加载时并行请求的最大数量将小于或等于30\n当试图满足最后两个条件时，最好使用较大的块。")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("     module.exports = {\n       //...\n       optimization: {\n         splitChunks: {\n           chunks: 'all', //选择哪些块进行优化。当提供一个字符串，有效值为all，async和initial,，还可以通过函数来过滤所需的 chunks\n           minSize: 20000, // 表示抽取出来的文件在压缩前的最小大小，默认为 30000\n           minRemainingSize: 0, // 拆分后剩余的最小块大小超过限制来避免大小为零的模块\n           maxSize: 0, // 表示抽取出来的文件在压缩前的最大大小，默认为 0，表示不限制最大大小\n           minChunks: 1,  // 拆分前必须共享模块的最小块数\n           maxAsyncRequests: 30, // 按需加载时(异步)最大并行请求数\n           maxInitialRequests: 30, // 入口点的最大并行请求数,最大的初始化加载次数，默认为 3；\n           automaticNameDelimiter: '~',\n           name:true,//name：抽取出来文件的名字，默认为 true，表示自动生成文件名；\n           enforceSizeThreshold: 50000, // 生成块的最小大小（以字节为单位）\n           cacheGroups: { //  缓存组,继承/覆盖上面 splitChunks 中所有的参数值,除此之外还额外提供了三个配置，分别为：test, priority 和 reuseExistingChunk。\n             defaultVendors: {\n               test: /[\\\\/]node_modules[\\\\/]/,\n               priority: -10\n             },\n             default: {\n               minChunks: 2,\n               priority: -20,\n               reuseExistingChunk: true\n             },\n             common: {\n                 name: 'common',\n                 chunks: 'initial',\n                 priority: 2,\n                 minChunks: 2,\n             },\n           }\n         }\n       }\n      ;\n\n")])])]),s("p",[e._v("下面我们把所有 node_modules 的模块被不同的 chunk 引入超过 1 次的抽取为 common。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("cacheGroups: {\n  common: {\n    test: /[\\\\/]node_modules[\\\\/]/,\n    name: 'common',\n    chunks: 'initial',\n    priority: 2,\n    minChunks: 2,\n  },\n}\n")])])]),s("p",[e._v("或者干脆把所有模块被不同的 chunk 引入超过 1 次的抽取为 common。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("cacheGroups: {\n  common: {\n    name: 'common',\n    chunks: 'initial',\n    priority: 2,\n    minChunks: 2,\n  },\n}\n")])])]),s("p",[e._v("进一步抽取,比如我们想把一些基础的框架单独抽取如 react ，然后是业务的基础。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("cacheGroups: {\n  reactBase: {\n    name: 'reactBase',\n    test: (module) => {\n        return /react|redux|prop-types/.test(module.context);\n    },\n    chunks: 'initial',\n    priority: 10,\n  },\n  common: {\n    name: 'common',\n    chunks: 'initial',\n    priority: 2,\n    minChunks: 2,\n  },\n}\n")])])]),s("p",[e._v("提供了 test 和 chunks 来过滤筛选但是如果要实现更精细的控制，就会发现还是有点问题。  从 entry 入口里面定义一个 react 的基础库，核心代码如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  const vendorPkg = [\n  'react',\n  'react-dom',\n  'redux',\n  'redux-thunk',\n  'react-redux',\n  'react-router-dom',\n  'react-router-redux',\n  'history',\n  'prop-types',\n  'react-loadable',\n];\n\nmodule.exports = {\n  entry: {\n    vendor: vendorPkg,\n    ...\n  }\n}\n")])])]),s("p",[e._v("其他页面无法共用这个 vendor")]),e._v(" "),s("p",[e._v("通过 MiniCssExtractPlugin 生成的 CSS 文件也可以通过 SplitChunks 来进行抽取公有样式等。如下表示将所有 CSS 文件打包为一个（注意将权重设置为最高，不然可能其他的 cacheGroups 会提前打包一部分样式文件）：")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    module.exports = {\n      optimization: {\n        splitChunks: {\n          cacheGroups: {\n            styles: {\n              name: 'styles',\n              test: /\\.css$/,\n              chunks: 'all',\n              enforce: true,\n              priority: 20, \n            }\n          }\n        }\n      }\n    }\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);