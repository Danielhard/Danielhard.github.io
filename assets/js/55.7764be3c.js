(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{254:function(n,e,s){"use strict";s.r(e);var o=s(0),a=Object(o.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h2",{attrs:{id:"webpack-基本构成模块及其内部原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack-基本构成模块及其内部原理","aria-hidden":"true"}},[n._v("#")]),n._v(" webpack 基本构成模块及其内部原理")]),n._v(" "),s("h3",{attrs:{id:"loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loader","aria-hidden":"true"}},[n._v("#")]),n._v(" loader")]),n._v(" "),s("ul",[s("li",[n._v("通过 loader-utils 插件，获配置环境中的参数")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('\n const loaderUtils = require("loader-utils")\n module.exports  = function(content){\n     const options = loaderUtils.getOptions(this);\n     console.log(this.data)//前置钩子\n     return ...\n }\n')])])]),s("ul",[s("li",[n._v("前置钩子")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("  module.exports.pitch = function(r,request,data){\n    data.value = '前置钩子'\n  }\n")])])]),s("h2",{attrs:{id:"打包生成的-bundle-里面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#打包生成的-bundle-里面","aria-hidden":"true"}},[n._v("#")]),n._v(" 打包生成的 bundle 里面")]),n._v(" "),s("ul",[s("li",[n._v("打包原理")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" 默认生成一个闭包，传入chunks对应的依赖\n\n(\n    function(modules){\n        var installModules = {}; // 缓存\n        function _webpack_require(moduleId){\n            if(installModules[moduleId]){\n                 return installModules[moduleId].exports //走缓存\n            }\n\n            var module = installedModules[moduleId] = {\n                export:{}\n            }\n            modules[moduleId].call(module.exports,module,module.exports,_webpack_require_) // 取闭包参数，执行方法。绑定参数\n            return module.exports // 导出的暴露出去\n        }\n    }\n    return _webpack_require('./xx/index.js')\n)({\n    \"./xx/index.js\":\n    (function(module,module.exports,_webpack_require_ ){\n        eval('...')\n    })\n})\n")])])]),s("ul",[s("li",[n._v("如果采用了同步加载 import ,require....，")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\n(\n    function(modules){\n        var installModules = {}; // 缓存\n        function _webpack_require(moduleId){\n            if(installModules[moduleId]){  //有缓存\n                 return installModules[moduleId].exports //走缓存\n            }\n\n            var module = installedModules[moduleId] = {\n                export:{}\n            }\n            modules[moduleId].call(module.exports,module,module.exports,_webpack_require_) // 取闭包参数，执行方法。绑定参数\n            return module.exports // 导出的暴露出去\n        }\n    }\n    return _webpack_require('./xx/index.js')\n)({\n\n    // 同步，递归展平\n    \"./xx/index.js\":\n    (function(module,module.exports,_webpack_require_ ){\n       /*harmony import */\n       var _sync_WEBPACK_IMPORTED_MODULE_0__ = _webpack_require_(/*! sync*/ \\'./xx/sync.js')\n       console.log(_sync_WEBPACK_IMPORT_MODULE_)_['default'] //\n       //异步的(import commonJS)会展平，用自己的定义的方式引入\n    }),\n     \"./xx/sync.js\":\n    (function(module,module.exports,_webpack_require_ ){\n        const data = 'sync'\n        /* harmony default export */\n        _webpack_exports_['default'] = (data) // 会用webpack自定义的模块化机制挂到default 属性上\n    })\n})\n")])])]),s("ul",[s("li",[n._v("异步打包")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("// index.js\nimport ('./async.js').then(res=>{\n    console.log(res)\n})\n")])])]),s("p",[s("strong",[n._v("异步引入会生成一个新的 chunk")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("// 打包后的[chunk].js\n\n//第八步:执行window['webpackJsonp'].push()方法，执行push方法就是执行webpackJsonpCallback方法\n(window['webpackJsonp'] = []).push([[0],{ // 推一个二维数组，第一个是chunkId ,第二个是chunk和依赖映射关系\n  \"./xx/async.js\":\n  (function(module,_webpack_exports_,_webpack_require){\n      const data = 'async'\n      /* harmony default*/\n      _webpack_exports_['default'] = (data)\n  })\n}])\n\n\n// 打包后的输出主文件\n\n(\n    function(modules){\n        // 第一步：定义变量和函数\n        \n        //[函数]异步回调函数\n        //[作用]加载异步文件中的chunk和module\n        // 这里的chunk是异步文件中的异步文件\n        // 这里的module代表异步文件中的主函数和同步文件\n\n        function webpackJsonpCallback(data){\n           // 第九步: 执行异步回调函数\n           // data结构\n           // [\n           //    [0],\n           //    {\n           //     './src/sync.js':function(){}\n           //    }\n           // ]\n          \n           // chunkIds拿到异步文件列表\n           // moreModules拿到同步和主函数文件\n            var chunkIds = data[0]\n            var moreModules = data[1];\n            var moduleId,chunkId,i = 0,resolves = [];\n            // 此时chunkIds = [0],chunkIds.length为1\n            for(;i<chunkIds.length;i++){\n                //chunkUd = 0\n                chunkId = chunkIds[i]\n\n                // 下面这个判断语句是判断installedChunks这个对象里面有没有chunkId,并且要有值\n                // installedChunks = {\n                //  0:[resolve,reject]\n                //  main:0   \n                // }\n                if(Object.prototype.hasOwnProperty.call(installedChunks,chunkId) && installedChunks){\n                   // installedChunks[0][0] 就是resolve函数\n                    resolves.push(installedChunks[chunkId][0]);\n                }\n                // 把此异步的属性值赋值为0,防止重复加载\n                installedChunks[chunkId] = 0;\n            }\n\n            // moreModules 是主文件和同步文件对象\n            // moreModules = {\n            //  './src/sync.js':function(){}   \n            // }\n            for(moduleId in moreModules){\n                if(Object.prototype.hasOwnProperty.call(moreModules,moduleId)){\n                    //此时的moduleId 为 './src/sync.js'\n                    //执行前 modules的值为:\n                    //modules = {\n                    // './src/index.js':function(){}    \n                    //}\n                    // 执行后,modules的值为:\n                    //  modules = {\n                    //    './src/index.js':function(){},\n                    //    '.src/sync.js':function(){}\n                    //    }\n\n\n\n                    // 把异步函数的文件挂载到modules上面\n                    modules[moduleId] = moreModules[moduleId];  // 执行一个就挂到modules上,\n                }\n            }\n            if(parentJsonpFunction)parentJsonpFunction(data);\n\n            // 第十步，resolves.shift()拿出resolve待执行函数，用()来执行,这里才执行了resolve\n            while(resolves.length){\n                resolves.shift()();\n            }\n        }\n        var installModules = {}; // 缓存\n\n        // 装载chunk(加载异步文件的一个对象，比如: 0:[resolve,reject,promise])\n        var installedChunks = {\n            'main':0\n        }\n\n        //[函数]返回文件路径\n        //[作用]通过chunk拼接src路径 \n        // script path function\n        function jsonpScriptSrc(chunkId){\n            return _webpack_require_.p + '' +({}[chunkId] || chunkId) + '.js'\n        }\n\n        //[函数]require函数\n        //[作用]这个是webpack自己定义的同步文件加载函数\n        function _webpack_require(moduleId){\n            // 第三步:执行主文件，此时的moduleId = './src/index.js'\n\n            //检查有没有缓存\n            //缓存模块installModules={}\n            if(installModules[moduleId]){\n                // 加载过，直接返回exports函数\n                 return installModules[moduleId].exports //走缓存\n            }\n            // 创建一个module,并且在installedModules上挂一个缓存，如果下次再执行，就直接走到上边的if语句里\n            var module = installedModules[moduleId] = {\n                export:{}\n            }\n            // 这个modules是最外层的modules\n            //webpack会把所有的文件都挂载到modules\n            //call有四个参数\n            //第一个是绑定this\n            //第二个是把上面创建的模块传进去\n            //第三个参数是module.exports,要导出的东西挂载在这个对象上\n            //第四个参数是_webpack_require_\n\n            modules[moduleId].call(module.exports,module,module.exports,_webpack_require_) // 取闭包参数，执行方法。绑定参数\n            //返回exports\n            return module.exports // 导出的暴露出去\n        }\n        \n        // [函数]异步文件加载  \n        // [作用]这个是重点\n        _webpack_require.e = function requireEnsure(chunkId){\n          // 第六步: 进入异步加载文件函数,此时chunkId = 0;\n          // 定一个存放promise的 集合  \n          var promises = [];\n\n          //用JSONP的模式加载(利用script标签记载)\n          //定义一个变量installedChunkData,然后看chunk装载函数有没有装载过chunkId = 0 的文件，如果没有就装载\n          var installedChunkData = installedChunks[chunkId]; // 拿到存放主文件的chunkId\n          //0代表安装过\n          if(installedChunkData !== 0){\n\n              // 如果installedChunkdata不为0,并且有值,就在promise变量里面放一个promise对象,在下面用Promise.all执行\n              if(installedChunkData){\n                  //第一次执行过后,installedChunkData = [resolve,reject,promise] ,第二个值是promise对象\n                  promises.push(installedChunkData[2]) //  检查缓存\n              }else{\n                  // 这里创建了一个promise对象，这里没有立即执行resolve,而是把值赋给全局变量installedChunksData 和installChunks\n                  //installedChunkData这个是上面创建的新变量，第一次进来是undefined,现在的installedChunkData = [resolve,reject]\n                  // installedChunks这个是用来装载异步文件的，此时的值\n                  // installedChunks = {\n                  //  0:[resolve,reject]\n                  //    main : 0  \n                  //  }\n                \n\n                  var promise = new Promise(function(resolve,reject){\n                      installedChunkData = installedChunks[chunkId] = [resolve,reject];\n                  })\n\n                  // push一个promise对象\n                  promises.push(installedChunkData[2] = promise);\n                  //异步通过script标签引入\n                  var script = document.createElement('script');\n                  var onScriptComplete;\n                  script.charset = 'utf-8';\n                  script.timeout = 120;\n                  if(_webpack_require_.nc){\n                      script.setAttribute('nonce',_webpack_require_.nc);\n                  }\n                  script.src = jsonpScriptSrc(chunkId);\n                  var error = new Error();\n                  onScriptComplete = function(event){\n                      script.onerror = script.onload = null;\n                      clearTimeout(timeout);\n                      var chunk = installedChunks[chunkId];\n                      if(chunk!==0){\n                          if(chunk){\n                              var erorrType = event&&(event.type ==='load'?'missing':event.type);\n                              var realSrc = event && event.target&&event.target.src;\n                              error.message = 'loading chunk ' + chunkId + 'failed.\\n(' + errorType + ':\n                              ...\n                              ...///执行错误安全类的\n                          }\n                      }\n                  }\n                  var timeout = setTimeout(function(){\n                      onScriptComplete({type:'timeout',target:script});\n                  },120000);\n                  script.onerror = script.onload = onScriptComplete;\n\n                  //第七步:加载这个文件会执行0.js\n                  document.head.appendChild(script) // 插入标签\n              }\n          }\n\n          // 第七点五步：先会同步执行返回\n           return Promise.all(promises) // 返回promiseAll ,用then接受\n        }\n        // 文件名前缀，在上面返回路径的函数中用到\n        _webpack_require_.p = ''\n        // 用jsonpArray代替变量window['webpackJsonp'];\n        var jsonpArray = window['webpackJsonp] = window['webpackJsonp'] || []; //简单的赋值\n        var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);  // 数组push绑定到oldJsonpFunction  oldJsonpFunction(1)->jsonpArray.push(1)\n        jsonpArray.push = webpackJsonpCallback; // push执行调用webpackJsonpCallback(上面定义的异步回调函数); push不是数组push\n        jsonpArray = jsonpArray.slice();\n        for(var i = 0;i<jsonpArray.length;i++) webpackJsonpCallback(jsonpArray[i]); // 调用传参  window['webpackJsonp'][0]\n        var parentJsonpFunction = oldJsonpFunction;\n        return _webpack_require_(_webpack_require_.s = './xx/index.js')\n    }\n\n    // 第二步:执行入口文件'./src/index.js'\n    return _webpack_require('./xx/index.js')\n)({\n    \"./xx/index.js\":\n    (function(module,module.exports,_webpack_require_ ){\n        // 第四步： 执行eval函数\n      eval(\n       _webpack_require_\n       .e(/* import() */0)  // 第五步，执行 _webpack_require_.e(0)\n       .then(_webpack_require_.bind(null,/*! ./async.js*/ \\\"./XX/async.js\\\")) // 第十一步，执行这个回调函数  _webpack_require_()\n       .then(res=>{ \n           \\n\\n\n           //第十二步： 异步加载完执行主函数剩下的逻辑输出\n           console.log(res)\n       })\n      )\n    })\n})\n")])])]),s("h2",{attrs:{id:"loader-ast-抽象语法树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loader-ast-抽象语法树","aria-hidden":"true"}},[n._v("#")]),n._v(" loader AST 抽象语法树")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('//简单抽象语法树实现\nvar UglifyJS =  require("uglify-js");\nvar code = "var a = 1;";\nvar toplevel = UglifyJS.parse(Code);\nvar transformer = new UglifyJS.TreeTransformer(function(node){\n    if(node instanceof UglifyJS.AST_Number){\n    node.value = \'0x\' + Number(node.value).toSting(16);\n    return node; //返回一个新的叶子节点替换原来的叶子结点\n    }\n});\ntoplevel.tansform(transformer);//遍历AST树\nvar ncode = toplevel.print_to_string();//从AST还原成字符串\nconsole.log(ncode); // var a = 0x1\n\n')])])]),s("p",[n._v("那么回到之前的 loader 实现原理部分")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" const acorn = require('acorn');\n const walk = require('acorn-walk');\n const MagicString = require('macgic-string');\n const loaderUtils = require(\"loader-utils\")\n module.exports = function(content){\n     const options = loaderUtils.getOptions(this);\n     const ast = acorn.parse(content); //转成ast树\n     const code = new MagicString(content); //魔法字符串\n     //做一个var => const\n     walk.simple(ast,{\n         VariableDeclaration(node){\n           const {start} = node\n           code.overwrite(start,start + 3,'const');\n         }\n     })\n     console.log(this.data)//前置钩子\n     return ...\n }\n\n")])])]),s("p",[n._v("编写自己的 loader use:[XXX,XXX]是以传入顺序的倒叙执行,最后的 loader 最早调用。传入原始文件，第一个 loader 最后调用，\n期待接受 js 和 sourceMap(可选)传入上一个执行返回结果。loader 的异步处理。在 loader 结束使用 this.async()标识该 loader 是异步\n处理的，使用 this.callback 返回 loader 处理结果。")]),n._v(" "),s("p",[s("strong",[n._v("(v8-compiler-cache 是个好东西[doge])")])]),n._v(" "),s("h2",{attrs:{id:"plugins的机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#plugins的机制","aria-hidden":"true"}},[n._v("#")]),n._v(" plugins的机制")]),n._v(" "),s("blockquote",[s("p",[n._v("tapable事件流机制")])]),n._v(" "),s("p",[s("strong",[n._v("一般编写自定义plugin的格式")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("const pluginName = 'ConsoleLogOnBuildWebpackPlugin';\n\nclass ConsoleLogOnBuildWebpackPlugin {\n    apply(compiler) {\n        compiler.hooks.run.tap(pluginName, compilation => {\n            console.log('The webpack build process is starting!!!');\n        });\n    }\n}\n\nmodule.exports = ConsoleLogOnBuildWebpackPlugin;\n")])])]),s("p",[s("strong",[n._v("tapable有一套自己的东西")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('const {\n    SyncHook,\n    SyncBailHook,\n    SyncLoopHook,\n    SyncWaterfallHook,\n    AsyncSeriesHook,\n    AsyncParallelHook,\n    AsyncSeriesBailHook,\n    AsyncParallelBailHook,\n    AsyncSeriesWaterfallHook\n} = require(\'tapable\')\n\n// 1.SyncHook 同步串行钩子 不关心返回值\n// 2.SyncBailHook 同步串行钩子 如果返回值不为null 则跳过之后的函数\n// 3.SyncLoopHook 同步循环，如果返回值为true 则继续执行\n// 4.SyncWaterfallHook同步串行，上一个函数返回值会传给下一个监听函数\n// 5.AsyncSeriesHook 异步并发 不关心返回值\n// 6.AsyncParallelHook 异步并发 不关心返回值\n// 7.AsyncSeriesBailHook 异步串行 返回值不为null时 执行异步里的回调函数\n// 8.AsyncParallelBailHook, 异步并发 返回值不为null 跳过之后的函数\n// 9.AsyncSeriesWaterfallHook 异步串行\n\n// 发布者\nlet run = new SyncHook([\'complation\', \'complation2\'])\n\n// 订阅者\nrun.tap("1", function (complation, complation2){\n    console.log("1:", complation, complation2)\n})\n\nrun.tap("2", function (complation) {\n    console.log("2:", complation)\n})\n\nrun.tap("3", function (complation) {\n    console.log("3:", complation)\n})\n\nrun.call("webpack", "other")\n')])])])])}),[],!1,null,null,null);e.default=a.exports}}]);